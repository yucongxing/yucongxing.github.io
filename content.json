{"meta":{"title":"yucongxing","subtitle":"","description":"郁聪兴的博客","author":"yucongxing","url":"https://yucongxing.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-08-05T09:25:00.808Z","updated":"2021-10-17T09:28:32.736Z","comments":false,"path":"/404.html","permalink":"https://yucongxing.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-08-05T09:25:00.808Z","updated":"2021-10-17T09:28:32.736Z","comments":false,"path":"about/index.html","permalink":"https://yucongxing.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2022-08-05T09:25:00.808Z","updated":"2021-10-17T09:28:32.736Z","comments":false,"path":"books/index.html","permalink":"https://yucongxing.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-08-05T09:25:00.808Z","updated":"2021-10-17T09:28:32.736Z","comments":false,"path":"categories/index.html","permalink":"https://yucongxing.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-08-05T09:25:00.808Z","updated":"2021-10-17T09:28:32.736Z","comments":true,"path":"links/index.html","permalink":"https://yucongxing.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-08-05T09:25:00.808Z","updated":"2021-11-08T13:08:05.908Z","comments":false,"path":"repository/index.html","permalink":"https://yucongxing.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-08-05T09:25:00.808Z","updated":"2021-10-17T09:28:32.736Z","comments":false,"path":"tags/index.html","permalink":"https://yucongxing.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++函数参数匹配","slug":"C-函数参数匹配","date":"2021-11-08T12:27:14.000Z","updated":"2021-11-12T10:11:55.817Z","comments":true,"path":"2021/11/08/62973a26.html","link":"","permalink":"https://yucongxing.github.io/2021/11/08/62973a26.html","excerpt":"","text":"C++ 函数参数匹配 单个参数匹配 123456789void f(); //f1void f(int); //f2void f(int, int); //f3void f(double, double=3.14);//f4int main() &#123; f(5.6); //调用f4 return 0;&#125; candidate functions:函数名称相同(f1, f2, f3, f4 都是)。 viable functions:参数个数相同(排除f1, f3)，且参数可以转换成相同类型(f2, f4都是viable function)。如果不存在viable functions，则编译器报参数不匹配错误（可以通过linting检查）。 最后决定参数类型是否匹配，如果匹配优先调用，不能则选择可以隐式转换成类型相同的函数。 多个参数匹配 123456789void f(); //f1void f(int); //f2void f(int, int); //f3void f(double, double=3.14);//f4int main() &#123; f(42, 5.6); //报错，参数模糊 return 0;&#125; condidate functions: f1, f2, f3, f4 viable functions: f3, f4 优先级: 精确匹配的参数个数越多优先级越高，参数个数相同优先级相同，如果存在多个最高优先级的函数，则报参数模糊错误。 参数类型转换 优先级： 精确匹配：包括类型相同， 数组和参数名转换为指针，忽略顶层const const 转换 (把非const实参传给const形参) promotion数据提升，如int-&gt;long, char-&gt;unsigned等 算术转换或者指针类型转换 类类型(class-type)转换，如string-&gt;bool Promotion and Arithmetic Conversion 1234567891011void ff(int); //f1void ff(short); //f2void manip(long); //f3void manip(float); //f4int main() &#123; ff(&#x27;a&#x27;); //调用f1，char-&gt;int是promotionO（比int短的数据类型统一promotion为int），char-&gt;short 是算术转换 manip(3.14); //error: ambiguous call，3.14视为double,double-&gt;float和doule-&gt;long在优先级上是等价的 return 0;&#125; const Arguments 忽略顶层const, 原因是传参的时候实际上进行的是copy过程，即copy一份实参给形参，copy会忽略顶层const 12345void f(int a);void f(const int a);//报错，重复定义，两者只能定义一种void f(int *a);void f(int* const a);//报错，重复定义，两者只能定义一种 const 转换 12345678910void f(int &amp;); //f1void f(const int &amp;);//f2int main() &#123; const int a&#123;0&#125;; int b&#123;0&#125;; f(a); //调用f2(精确匹配) f(b); //调用f1(没有定义f1时，调用f2) return 0;&#125; 另外， 1234567void f(int);void f(int &amp;);int main() &#123; int i = 0; f(i); //报错，ambiguous call&#125;","categories":[],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"https://yucongxing.github.io/tags/C-Primer/"}]},{"title":"如何使用hexo发布一篇博客？","slug":"如何使用hexo发布一篇博客？","date":"2021-10-17T07:04:15.000Z","updated":"2021-11-08T12:31:12.032Z","comments":true,"path":"2021/10/17/7f722911.html","link":"","permalink":"https://yucongxing.github.io/2021/10/17/7f722911.html","excerpt":"","text":"怎么发布一篇博客？ 安装并部署hexo 运行hexo new &quot;blogtitle&quot; 找到hexo文件夹中的source/_post/blogtitle.md文件，并编写你的内容。 编写完成后，运行hexo generate把markdown文件渲染为静态网页文件，然后再运行hexo server &quot;port number&quot;，并登陆到localhost:&quot;port number&quot;进行预览。 最后运行hexo deploy把博客部署推送到服务器。 以我的文件夹 /var/www/hexo 为例： 12345678910111213cd /var/www/hexohexo new &quot;my first blog&quot;nvim ./source/_post/my-first-blog.mdhexo generatehexo server 4000 //if you have a browserhexo deploy 详细文档见hexo文档","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://yucongxing.github.io/tags/hexo/"}]},{"title":"计算机组成原理","slug":"计算机组成原理","date":"2021-03-03T13:00:45.000Z","updated":"2021-11-09T16:06:51.873Z","comments":true,"path":"2021/03/03/8d4b7ae1.html","link":"","permalink":"https://yucongxing.github.io/2021/03/03/8d4b7ae1.html","excerpt":"","text":"计算机组成原理 这门课讲什么： 计算机 + 组成 + 原理 基本部件的结构和组织方式 基本运算的操作原理 基本部件和单元的设计思想 特色 计算机组成的一般原理，不以具体机型为依托 采用自顶向下的方式、层层细化 第一章 计算机系统概论 计算机系统简介 现代计算机的多态性 从传感器到大型服务器再到超级计算机 物联网就是一个巨大的计算机–&gt;智慧地球 一、计算机的软硬件概念 计算机系统：硬件、软件 软件：系统软件、应用软件 系统软件：语言处理程序、操作系统、服务性程序、数据库管理系统、网络软件 应用软件：按需求设计的一系列软件 二、计算机系统的层次结构 系统复杂性管理的方法-1 抽象 三、 计算机体系结构和计算机组成 计算机体系结构 程序员缩减到的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I/O机理） 计算机组成 实现计算机体系结构所体现的属性 计算机的基本组成 一、冯·诺伊曼计算机的特点 计算机有五大部件组成 指令和数据以同等地位存于存储器，可按地址寻访 指令和数据用二进制表示 指令由操作码和地址吗组成 存储程序（最重要的特点） 以运算器为中心 二、计算机硬件框图 以存储器为中心的计算机硬件框图 现代计算机硬件框图 系统复杂性管理的方法-2 层次化 模块化 规则性 存储器的基本组成：存储体、MAR、MDR MAR：存储地址寄存器（反应存储单元的个数） MDR：存储器数据寄存器（反映存储字长） 计算机硬件的主要技术指标 机器字长：CPU一次能处理数据的位数，与CPU的寄存器位数有关，机器字长越长性能越好 运算速度： 主频（没有直接的关系） 核数，每个核支持的线程数 吉普森法 CPI 执行一条指令所需时钟周期数 MIPS 每秒执行百万条指令 FLOPS 每秒浮点运算次数 存储容量（存放二进制信息的总位数）： 主存容量： 存储单元个数 × 存储字长 字节数 辅存容量：字节数 第二章 计算机的发展及应用 计算机的发展史 第三章 系统总线 总线的基本概念 为什么要用总线 什么是总线：总线是连接各个部件的信息传输线，是各个部件共享的传输介质。 总线上信息传输的方式：并行和串行 总线结构的计算机举例 单总线结构框图 面向CPU的双总线结构框图 以存储器为中心的双总线结构框图 总线的分类 片内总线 芯片内部的总线 系统总线 计算机各部件之间的信息传输 数据总线：双向 与机器字长、存储字长有关 地址总线：单向 与存储地址、I/O地址有关 控制总线 有出 有入 通信总线 总线特性及性能指标 一、总线物理实现 二、总线特性 机械特性：尺寸、形状、管脚数、排序顺序 电器特性：传输方向和有效的电平范围 功能特性：每根传输线的功能：地址、数据、控制 时间特性：信号的时序关系 三、总线的性能指标 总线宽度：数据线的根数 标准传输率：每秒传输的最大字节数 时钟同步/异步：同步、不同步 总线复用：地址线与数据线复用 信号线数：地址线、数据线和控制线的总和 总线控制方式：突发、自动、仲裁、逻辑、计数 其他指标：负载能力 四、总线标准 总线结构 一、单总线结构 二、多总线结构 双总线结构：主存总线 I/O总线 三总线结构： 主存总线 I/O总线 DMA总线 局部总线（CPU和cache） 系统总线（主存和cache） 扩展总线（系统总线和外设） 四总线结构：局部总线（CPU和cache） 系统总线（主存和cache） 高速总线（桥和高速设备） 扩展总线（高速总线和外设） 三、总线结构举例 传统微型机总线结构 VL-BUS局部总线结构 PCI总线结构 多层PCI总线结构 总线控制 一、总线判优控制 基本概念 主设备：对总线有控制权 从设备： 响应从主设备发来的总线命令 总线判优控制 集中式：链式查询 计数器定时查询 独立请求方式 分布式 链式查询方式：特有BG线 计数器定时查询方式：特有设备线 独立请求方式：每个设备有独立的BR和BG 二、总线通信控制 目的 解决通信双方协调配合问题 总线传输周期： 申请分配阶段：主模块申请，总线重在决定 寻址阶段：主模块向从模块给出地址和命令 传数阶段：主模块和从模块交换数据 结束阶段：主模块撤销有关消息 总线通信的四种方式 同步通信 由统一时标控制数据传送 异步通信 采用应答方式，没有公共时钟标准 不互锁 半互锁 全互锁 半同步通信 同步异步结合 分离式通信 充分挖掘系统总线每个瞬间的潜力 各个模块有权申请占用总线 采用同步方式通信，不等对刚回答 各个模块准备数据是，不占用总线 总线被占用时，没有空闲时间 第四章 存储器 概述 一、存储器分类 按存储介质分类 半导体存储器 TTL、MOS 磁表面存储器 磁头、磁载体 （非易失） 磁芯存储器 硬磁材料、环状元件 （非易失） 光盘存储器 激光、磁光材料 （非易失） 按存取方式分类 存取时间与物理地址无关（随机访问） 随机存储器 只读存储器 存期时间与物理地址有关（串行访问） 顺序存取存储器 磁带 直接存取存储器 磁盘 按在计算机中的作用分类 主存储器 RAM 静态RAM 动态RAM ROM MROM PROM EPROM EEPROM 辅助存储器 磁盘、磁带、光盘 Flash Memory Cache（高速缓冲存储器） 二、存储器的层次结构 存储器三个主要特性的关系 速度 容量 价格/位 缓存-主存层次和主存-辅存层次 主存储器 一、概述 主存的基本组成 主存和CPU的联系 数据总线 地址总线 控制主线 读、写 主存中存储单元地址的分配 主存的技术指标 存储容量 存储速度 存取时间 存取周期 存储器带宽 二、半导体存储芯片简介 半导体存储芯片的基本结构 （片选线+读/写控制线）数据线+地址线+译码驱动+存储矩阵+读写电路 半导体存储芯片的译码驱动方式 线选法 重合法 三、随机存取存储器 静态RAM（SRAM） 静态RAM基本单元电路 静态RAM芯片举例（Intel 2114） 动态RAM（DRAM） 动态RAM基本单元电路（读出与原存信息相反，写入与输入信息相同） 三管动态RAM芯片举例（Intel 1103） 单管RAM4116（16K×1位）外特性 动态RAM刷新（刷新只与行地址有关） 集中刷新 分散刷新 异步刷新 动态RAM和静态RAM的比较 DRAM SRAM 存储原理 电容 触发器 集成度 高 低 芯片引脚 少 多 功耗 小 大 价格 低 高 速度 慢 快 刷新 有 无 用途 主存 cache 四、只读存储器（ROM） 掩膜ROM（MROM） PROM（一次性编程） EPROM（多次性编程）（浮动栅MOS电路） EEPROM（多次性编程） 电可擦写 局部擦写 全部擦写 Flash Memory（闪存） 五、存储器与CPU的连接 存储器容量的扩展 位扩展（增加存储字长） 地址线连相同的信号，数据线分开连接 字扩展（增加存储字的数量） 字位扩展 存储器与CPU的连接 地址线的连接 数据线的连接 读/写命令线的连接 片选线的连接 合理选择存储芯片 其他 时序、负载… 六、存储器的校验 编码的最小距离：任意两组合法代码之间二进制位数的最少差异 L−1=D+C(D≥C)L-1=D+C(D\\geq{C}) L−1=D+C(D≥C) L:编码的最小距离 D:检测错误的位数 C:纠正错误的位数 汉明码的组成 汉明码采用奇偶校验 汉明码采用分组校验 汉明码的分组式一种非划分方式（即各组之间有重叠） 汉明码的纠错过程 七、提高访存速度的措施 单体多字系统（每次读取多个处理器字长的数据） 多体并行系统 高位交叉 顺序编址 地位交叉 各个体轮流编址 不改变存取周期的前提下，增加存储器的带宽 高性能存储芯片 SDRAM（同步DRAM） RDRAM 带cache的DRAM 高速缓冲存储器 一、概述 问题的提出 避免CPU&quot;空等&quot;现象 CPU和主存（DRAM）的速度差异 程序访问的局部性原理（时间局部性 空间局部性） Cache的工作原理 主存和缓存的编址 命中和不命中 Cache的命中率（与Cache的容量、块长有关） 一般可取4~8个字 块长去一个存取周期内从主存读取的数据长度 Cache——主存系统的效率 效率e与命中率有关 Cache的基本结构 Cache的读写操作 读 写 写直达法（Write-Through）（每次写操作都写回内存，增加了写操作的时间） 写回法（Write-back）（块替换时写回内存） Cache的改进 增加Cache的级数 片内Cache 片外Cache 统一缓存和分立缓存（指令和数据分开缓存） 二、Cache-主存的地址映射 直接映射 全相联映射 组相联映射 三、替换算法 先进先出（FIFO）算法 近期最少使用（LRU）算法 辅助存储器 一、概述 特点 不直接与CPU交换信息 磁表面存储器的技术指标 记录密度 存储容量 平均寻址时间 数据传输率 误码率 二、磁记录原理和记录方式 磁记录原理 三、硬磁盘存储器 硬磁盘存储器的类型 固定磁头和移动磁头 可换盘和固定盘 硬磁盘存储器结构 磁盘驱动器 磁盘控制器 盘片 四、软磁盘存储器 概述 五、光盘存储器 概述 采用光存储技术 利用激光写入和读出 光盘的存储原理 只读型和只写一次性 可擦写光盘 第五章 输入输出系统 概述 一、输入输出系统的发展概况 早期 分散连接 CPU和IO设备串行工作 程序查询方式 接口模块和DMA阶段 总线连接 CPU和IO设备 并行工作 中断方式 DMA方式 具有通道结构的阶段 具有IO处理机的阶段 二、输入输出系统的组成 I/O软件 I/O指令 CPU指令的一部分 通道指令 通道自身的指令 I/O硬件 三、I/O设备与主机的联系方式 I/O设备编址方式 统一编址 用取数、存数指令 不统一编址 有专门的I/O指令 设备选址 用设备选择电路识别是否被选中 传送方式 串行 并行 联络方式 立即响应 异步工作采用应答信号 同步工作采用同步时标 I/O设备与主机的连接方式 辐射式连接（分散连接） 总线连接 便于增删设备 四、I/O设备与主机信息传送的控制方式 程序查询方式 程序中断方式 DMA方式 主存和I/O之间有一条直接数据通道 不中断现行程序 周期挪用 三种方式的CPU工作效率比较：从上到下I/O系统的自治能力越来越强 外部设备 一、概述 外部设备大致分三类 人机交互设备 键盘、鼠标、打印机、显示器 计算机信息存储设备 磁盘、光盘、磁带 机—机通信设备 调制解调器 二、输入设备 键盘 按键 判断哪个键按下 将此键翻译成ASCII码 鼠标 机械式 光电式 触摸屏 三、输出设备 显示器 字符显示 字符发生器 图形显示 主观图像 图像显示 客观图像 打印机 打击式 点阵式（逐字、逐行） 非打字机 激光（逐页）、喷墨 四、其他 A/D、D/A 模拟/数字（数字/模拟）转换器 终端 由键盘和显示器组成 汉字处理 汉字输入、汉字存储、汉字输出 五、多媒体技术 什么时多媒体 多媒体计算机的关键技术（数据压缩、编码技术、语音图像识别） I/O接口 一、概述 为什么要设置接口？ 实现设备的选择 实现数据缓冲达到速度匹配 实现数据串—并格式转换 实现电平转黄 传送控制命令 反应设备的状态（“忙”、“就绪”、“中断请求”） 二、接口的功能和组成 总线连接方式的I/O接口电路 设备选择线 数据线 命令线 状态线 接口的功能和组成 功能 组成 选址功能 设备选择电路 传送命令的功能 命令寄存器、命令译码器 传送数据的功能 数据缓冲寄存器 反应设备状态的功能 设备状态标记 I/O接口的基本组成 三、接口类型 按数据传送方式 并行接口 串行接口 按功能选择的灵活性分类 可编程接口 不可编程接口 按通用性分类 通用接口 专用接口 按数据传送的控制方式分类 中断方式接口 DMA方式接口 程序查询方式 一、程序查询流程 查询流程 单个设备 多个设备：按优先级逐级查询 程序流程 二、程序查询方式的接口电路 程序中断方式 一、中断的概念 二、I/O中断的产生 三、程序中断方式的接口电路 配置中断请求触发器和中断屏蔽触发器 排队器 硬件实现 在CPU内或在接口电路中（链式排队器） 软件实现 中断向量地址形成部件 入口地址 由软件产生 详见第八章 硬件向量法 由硬件产生向量地址，再由向量地址找到入口地址 程序中断方式接口电路的基本组成 四、I/O中断处理过程 CPU响应中断的条件和时间 条件 允许中断触发器EINTEINTEINT=1 时间 当D=1D=1D=1（随机）且mask=0mask=0mask=0时 在每条指令执行阶段的结束前 CPU发中断查询信号（将INTR置“1”） I/O中断处理过程 五、中断服务程序流程 中断服务程序的流程 保护现场 程序断点的保护 中断隐指令完成 寄存器内容的保护 进栈指令 中断服务 对不同的I/O设备具有不同内容的设备服务 恢复现场 出栈指令 中断返回 中断返回指令 单重中断和多重中断 单重中断 ==不允许中断==现行的中断服务程序 多重中断 ==允许级别更高==的中断源中断现行的中断服务程序 单重中断和多重中断的服务程序流程 主程序和服务程序抢占CPU示意图 DMA方式 一、DMA方式的特点 DMA和程序中断两种方式的数据通路 DMA与主存交换数据的三种方式 停止CPU访问主存 控制简单 CPU处于不工作状态或保持状态 未充分发挥CPU对主存的利用率 周期挪用（周期窃取） DMA访问主存有三种可能 CPU此时不访问主存 CPU正在访问主存 CPU与DMA同时请求访问主存：此时CPU将总线控制权让给DMA DMA与CPU交替访问 CPU工作周期 C1专供DMA访存 C2专供CPU访存 二、DMA接口的功能和组成 DMA接口功能 向CPU申请DMA传送 处理总线控制权的转交 管理系统总线、控制数据传送 确定数据传送的首地址和长度 修正传送过程中的数据地址和长度 DMA传送结束时，给出操作完成信号 DMA接口组成 三、DMA的工作过程 DMA传送过程 预处理、数据传送、后处理 预处理 通知DMA控制逻辑传送方向 设备地址–&gt;DMA的DAR 主存地址–&gt;DMA的AR 传送字数–&gt;DMA的WC DMA传送过程示意 数据传送过程（输入主存） 数据传送过程（输出主存） 后处理 由中断服务程序完成 校验送入主存的数是否正确 是否继续用DMA 测试传送过程是否正确，错则转诊断程序 DMA接口与系统的连接方式 具有公共请求线的DMA请求 独立的DMA请求 DMA方式与程序中断方式的比较 中断方式 DMA方式 数据传送 程序 硬件 响应时间 指令执行结束 存取周期结束 处理异常情况 能 不能 中断请求 传送数据 后处理 优先级 低 高 四、DMA接口的类型 选择型 在物理上连接多个设备，在逻辑上只允许连接一个设备 多路型 在屋里上连接多个设备，在逻辑上允许连接多个设备同时工作（但是与主存交换数据只能一个） 多路型DMA接口的工作原理 第六章 计算机的运算方法 无符号数和有符号数 一、无符号数 寄存器的位数反应无符号数的范围 二、有符号数 机器数与真值 真值：带符号的数 +0.1011+0.1011+0.1011 −0.1011-0.1011−0.1011 +1100+1100+1100 −1100-1100−1100 机器数 符号数字化的数 010110101101011 110111101111011 011000110001100 111001110011100 原码表示法 定义 整数真值为xxx [x]原={0,x2n&gt;x≥02n−x0≥x&gt;−2n[x]_{原}=\\left\\{ \\begin{array} {cc}0,x &amp; 2^n &gt; x \\geq 0 \\\\ 2^n - x &amp; 0 \\geq x &gt; -2^n\\end{array}\\right.[x]原​={0,x2n−x​2n&gt;x≥00≥x&gt;−2n​ 小数真值为xxx [x]原={x1&gt;x≥01−x0≥x&gt;−1[x]_原=\\left\\{ \\begin{array}{cc} x &amp; 1&gt; x \\geq 0 \\\\ 1-x &amp; 0 \\geq x &gt;-1 \\end{array}\\right.[x]原​={x1−x​1&gt;x≥00≥x&gt;−1​ 原码的特点：简单、直观 但是运算困难 补码表示法 补的概念 一个负数加上==“模”==即的该负数的补数 一个整数和一个负数互为补数时，它们绝对值之和即为==模==数 整数的补数即为其本身 补码定义 整数 xxx为真值 nnn为整数的位数 [x]补={0,x2n&gt;x≥02n+1+x0&gt;x≥−2n(mod 2n+1)[x]_补=\\left\\{ \\begin{array}{cl} 0,x &amp; 2^n &gt; x \\geq 0 \\\\ 2^{n+1} + x &amp; 0 &gt; x \\geq -2^n(\\mod 2^{n+1})\\end{array} \\right.[x]补​={0,x2n+1+x​2n&gt;x≥00&gt;x≥−2n(mod2n+1)​ 小数 xxx为真值 [x]补={x1&gt;x≥02+x0&gt;x≥−1(mod 2)[x]_补=\\left \\{ \\begin{array}{cl} x &amp; 1 &gt; x \\geq 0 \\\\ 2+x &amp; 0&gt; x \\geq -1(\\mod 2)\\end{array}\\right.[x]补​={x2+x​1&gt;x≥00&gt;x≥−1(mod2)​ 求补码的快捷方式 正数补码与原码相同 负数符号位照抄，数值位对原码每位求反末位加1 反码表示法 定义 整数 xxx为真值 nnn为整数的位数 [x]反={0,x2n&gt;x≥0(2n+1−1)+x0≥x&gt;−2n(mod 2n+1−1)[x]_反 = \\left \\{ \\begin{array}{cl} 0,x &amp; 2^n &gt;x \\geq 0 \\\\ (2^{n+1}-1)+x &amp; 0 \\geq x &gt;-2^n (\\mod 2^{n+1}-1) \\end{array} \\right.[x]反​={0,x(2n+1−1)+x​2n&gt;x≥00≥x&gt;−2n(mod2n+1−1)​ 小数 [x]反={x1&gt;x≥0(2−2−n)+x0≥x&gt;−1(mod 2−2−n)[x]_反=\\left \\{ \\begin{array}{cl} x &amp; 1&gt;x\\geq0 \\\\ (2-2^{-n})+x &amp; 0\\geq x&gt;-1(\\mod 2-2^{-n})\\end{array}\\right.[x]反​={x(2−2−n)+x​1&gt;x≥00≥x&gt;−1(mod2−2−n)​ 移码表示法 补码表示很难直接判断其真值大小 定义 [x]移=2n+x (2n&gt;x≥−2n)[x]_移=2^n+x \\space (2^n&gt;x\\geq -2^n)[x]移​=2n+x (2n&gt;x≥−2n) 数的定点表示和浮点表示 一、顶点表示 按照小数点位置可分为小数定点机和整数定点机 二、浮点表示 为什么要引入浮点数表示 编程困难，程序员要调节小数点的位置 数的表示范围小，为了能表示两个大小相差很大的数据，需要很长的机器字长 N=S×rjN=S \\times r^jN=S×rj SSS 尾数 jjj 阶码 rrr位数的基值 计算机中rrr取2、4、6、8等 浮点数的表示形式 浮点数的表示范围 浮点数的规格化形式 浮点数的规格 三、举例 四、IEEE754标准 定点运算 一、移位运算 移位的意义：左移绝对值扩大，右移绝对值缩小 算术移位规则 符号位不变 正数 无论什么编码方式都添零 负数 原码左移右移都添零 反码左移右移都添1 补码左移添0，右移添1 算术移位的硬件实现 算数移位和逻辑移位的区别 算术移位是有符号数的移位 逻辑移位是无符号数的移位 二、加减法运算 补码加减运算公式 加法 举例 溢出判断 一位符号位判断溢出 参加操作的两个数符号相同，其结果的符号与原操作数的符号不同，即为溢出 硬件实现：最高有效位的进位⊕符号位的进位=1最高有效位的进位 \\oplus 符号位的进位=1最高有效位的进位⊕符号位的进位=1 则溢出 两位符号位判断溢出 [x]补={x1&gt;x≥04+x0&gt;x≥−1(mod 4)[x]_补 = \\left\\{\\begin{array}{cl} x &amp; 1 &gt; x \\geq 0 \\\\ 4 + x &amp; 0&gt;x \\geq -1 (\\mod 4) \\end{array} \\right.[x]补​={x4+x​1&gt;x≥00&gt;x≥−1(mod4)​ [x]补+[y]补=[x+y]补（mod 4）[x]_补 + [y]_补 = [x+y]_补 （\\mod 4）[x]补​+[y]补​=[x+y]补​（mod4） [x−y]补=[x]补+[−y]补(mod 4)[x-y]_补 = [x]_补+[-y]_补 (\\mod 4)[x−y]补​=[x]补​+[−y]补​(mod4) 结果的双符号位相同 未溢出 结果的双符号位不同 溢出 符号位的最高位代表了真正的符号 补码加减法的硬件配置 三、乘法运算 分析笔算乘法 笔算乘法改进 改进后的笔算乘法过程（竖式） 原码乘法 原码一位乘运算规则 举例 原码一位乘法的硬件配置 四、除法运算 分析笔算除法 笔算除法和机器除法的比较 原码除法 恢复余数法 不恢复余数法（加减交替法） 浮点数四则运算 一、浮点加减运算 x=Sx×2jxx=S_x\\times 2^{j_x}x=Sx​×2jx​ y=Sx×2jyy = S_x \\times 2^{j_y}y=Sx​×2jy​ 对阶 求阶差 Δj=jx−jy{=0jx=jy已对齐&gt;0jx&gt;jyy向x看齐&lt;0jx&lt;jyx向y看齐\\Delta j = j_x -j_y\\left\\{\\begin{array}{ccl} =0 &amp; j_x = j_y &amp; 已对齐 \\\\ &gt;0 &amp; j_x&gt;j_y &amp; y向x看齐 \\\\ &lt;0 &amp; j_x &lt;j_y &amp; x向y看齐\\end{array} \\right.Δj=jx​−jy​⎩⎪⎨⎪⎧​=0&gt;0&lt;0​jx​=jy​jx​&gt;jy​jx​&lt;jy​​已对齐y向x看齐x向y看齐​ 对阶原则：小阶向大阶看齐 尾数计算 规格化 规格化数的定义 r=2r = 2r=2 12≤∣x∣&lt;1\\frac{1}{2}\\leq|x|&lt;121​≤∣x∣&lt;1 规格化数的判断 原码 不论正负，第一位为1 补码 符号位和第一位不同 特例 [−12]补不是规格化数[-\\frac{1}{2}]_补不是规格化数[−21​]补​不是规格化数 [−1]补是规格化数[-1]_补是规格化数[−1]补​是规格化数 左规 太小时 右规 溢出时 舍入 位数的低位精度处理（出现在对阶和右规阶段） 0舍1入法 恒置“1”法 溢出判断 算术逻辑单元 一、ALU电路 二、快速进位链 并行加法器 串行进位链 进位链：传送进位的电路 串行进位链：进位串行传送 并行进位链：n位加法器的进位同时产生（先行进位，跳跃进位） 单重分组跳跃进位链：先并行再串行 双重分组跳跃进位链： 第七章 指令系统 机器指令 一、指令的一般格式 操作码字段+地址码字段 操作码 反映机器做什么操作 长度固定 用于指令比较长的情况，RISC 长度可变：X86系统 扩展操作码技术 操作码的位数随地址数的减少而增加 涉及到 哈夫曼编码 地址码 四地址 OP+A1+A2+A3+A4 (A1)OP(A2)→A3(A_1)OP(A_2)\\rightarrow A_3(A1​)OP(A2​)→A3​ A3A_3A3​ 存放到A4A_4A4​ 三地址（PC代替A4A_4A4​） OP+A1+A2+A3OP + A_1 + A_2 + A_3OP+A1​+A2​+A3​ 二地址 OP+A1+A2OP+A_1+A_2OP+A1​+A2​ 一地址（ACC代替A1A_1A1​ ） 零地址 二、指令字长 指令字长决定于：操作码的长度 操作数地址的长度 操作数地址的个数 指令字长固定 指令字长 = 存储字长 指令字长可变 变化一般时字节的倍数 操作数类型和操作种类 一、操作数类型 地址 无符号整数 数字 定点数、浮点数、十进制数 字符 ASCII 逻辑数 逻辑运算 二、数据再存储器中的存放方式 大端方式和小端方式 字节编址，数据在存储器中的存放方式（存储字长64位，机器字长32位） 从任意位置开始存储 不浪费存储资源 读写困难 从一个存储字的起始位置开始访问 读写容易 浪费空间 边界对准方式——从地址的整数倍位置开始访问 三、操作类型 数据传送 源 寄存器 目的 例如 算术逻辑操作 移位操作 转移 无条件转移 条件转移 调用和返回 陷阱（TRAP）与陷阱指令（意外事故的中断） 一般不提供给用户直接使用，出现事故时，由CPU自动产生执行 设置供用户使用的陷阱指令 输入输出 寻址方式 一、指令寻址 顺序 (PC)+1⟶PC(PC) + 1 \\longrightarrow PC(PC)+1⟶PC 跳跃 由转移指令指出下一条指令的地址 二、数据寻址 | 操作码 | 寻址特征 | 形式地址A | 形式地址 指令字中的地址 有效地址 操作数的真是地址 约定 指令字长=存储字长=机器字长 立即寻址形式地址A就是操作数 指令执行阶段不访存 直接寻址 EA=AEA = AEA=A 有效地址由形式地址直接给出 执行阶段访问一次存储器 A的位数决定了该指令操作数的寻址范围 操作数的地址不易直接修改（必须修改A） 隐含寻址操作数地址隐含在 操作码中 间接寻址 EA=(A)EA = (A)EA=(A) 有效地址由形式地址简介提供 执行阶段指令阶段2次访存 可扩大寻址范围 便于编制程序 寄存器（直接）寻址 EA=RiEA = R_iEA=Ri​ 有效地址即为寄存器编号 执行阶段不访存，只访问寄存器，执行速度快 寄存器个数有限，可缩短指令字长 寄存器间接寻址 EA=(Ri)EA = (R_i)EA=(Ri​) 有效地址在寄存器中 有效地址在寄存器中，操作数在存储器中，执行阶段 便于编制循环程序 基址寻址 采用专用寄存器作机制寄存器 EA=(BR)+AEA = (BR) + AEA=(BR)+A BR为基址寄存器 可扩大寻址范围 有利于多道程序 BR内容由操作系统或管理程序确定 在程序得执行过程中BR内容保持不变，形式地址A可变 采用通用寄存器作基址寄存器 由用户指定哪个寄存器作为基址寄存器 基址寄存器得内容由操作系统确定 在程序执行过程中R0内容不变，形式地址A可变 变址寻址 EA=(IX)+AEA = (IX) + AEA=(IX)+A IX为变址寄存器（专用） 通用寄存器也可以作为变址寄存器 可扩大寻址范围 IX的内容由用户给定 在程序的执行过程中IX内容可变，形式地址A不变 便于处理数组问题 相对寻址 EA=(PC）+AEA = (PC） + AEA=(PC）+A A是相对与当前指令的位移量（可正可负，补码） A的位数决定操作数的寻址范围 程序浮动 广泛用于转移指令 堆栈寻址 堆栈的特点{硬堆栈多个寄存器软堆栈指定的存储空间堆栈的特点\\left \\{ \\begin{array}{cc} 硬堆栈 &amp; 多个寄存器 \\\\ 软堆栈 &amp; 指定的存储空间 \\end{array}\\right.堆栈的特点{硬堆栈软堆栈​多个寄存器指定的存储空间​ 先进后出（一个出入口） 栈顶地址由SP指出 进栈(SP)−1→SP(SP) - 1 \\rightarrow SP(SP)−1→SP 出栈(SP)+1→SP(SP)+1 \\rightarrow SP(SP)+1→SP 指令格式举例 一、设计指令格式时应考虑的各种因素 指令系统的兼容性 其他因素 操作类型 包括指令个数及操作的难易程度 数据类型 确定哪些数据类型可参与操作 指令格式 指令字长是否固定 ​ 操作码位数、是否采用扩展操作码技术 ​ 地址码位数、地址个数、寻址方式类型 寻址方式 指令寻址、操作数寻址 寄存器个数 寄存器的多少直接影响指令的执行时间 计算机举例 IBM 360 RR格式 二地址R-R RX格式 二地址R-M 基址加变址寻址 RS格式 三地址R-M 基址寻址 SI格式 立即数-M 基址寻址 SS格式 二地址 M-M基址寻址 Intel 8086 指令字长 1~6个字节 地址格式 零地址 一地址 两地址 RISC技术 一、RISC的产生和发展 RISC(Reduced Instruction Set Computer) CISC(Complex Instruction Set Computer) 80–20规律 典型程序中80%的语句仅仅使用处理机中20%的指令。 二、RISC的主要特征 选用使用频度较高的一些简单指令，复杂指令的功能由简单指令来组合 指令长度固定、指令格式种类少、寻址方式少 只有LOAD/STORE指令访存 CPU中有多个通用寄存器 采用流水技术 一个时钟周期内完成一条指令 采用组合逻辑实现控制器 三、CISC的主要特征 系统指令复杂庞大，各种指令使用频度相差大 指令长度不固定、指令格式种类多、寻址方式多 访存指令不受限制 CPU中设有专用寄存器 大多数指令需要多个时钟周期来完成 采用微程序控制器 四、RISC和CISC的比较 RISC更能充分利用VLSI芯片的面积 RISC更能提高计算机运算速度 指令数、指令格式、寻址方式少 通用寄存器多，采用组合逻辑 便于实现指令流水 RISC便于设计，可降低成本，提高可靠性 RISC不易实现指令系统兼容 第八章 CPU的机构和功能 CPU的结构 一、CPU的功能 控制器的功能 取指令 分析指令 执行指令，发出各种操作命令 控制程序输入及结果的输出 总线管理 处理异常情况和特殊请求 运算器的功能 实现算术运算和逻辑运算 二、CPU结构框图 CPU与系统总线 三、CPU的寄存器 用户可见寄存器 通用寄存器 存放操作数 可作某种寻址方式所需的专用寄存器 数据寄存器 存放操作数（满足各种数据类型） 地址寄存器 存放地址，其位数应满足最大的地址范围 用于特殊的寻址方式 段基值 栈指针 条件码寄存器 存放条件码，可做程序分支的依据 如 正、负、零、溢出、进位、等 控制和状态寄存器 控制寄存器 PC→MAR→M→MDR→IRPC \\rightarrow MAR \\rightarrow M \\rightarrow MDR \\rightarrow IRPC→MAR→M→MDR→IR 控制CPU操作，其中MAR、MDR、IR用户不可见，PC用户可见 状态寄存器 状态寄存器 存放条件码 PSW寄存器 存放程序状态字 四、控制单元CU和中断系统 CU 产生全部指令的位操作命令序列 设计方法： 组合逻辑设计 硬连线逻辑 微程序设计 存储逻辑 中断系统 五、ALU 指令周期 一、指令周期的基本概念 指令周期：取出并执行一条指令所需的全部时间 完成一条指令： 取指令 分析指令 取指周期 执行指令 执行周期 每条指令的指令周期不同 具有间接寻址的指令周期 指令周期：取指周期 间址周期 执行周期 带有中断指令的指令周期 指令周期：取指周期 间址周期 执行周期 中断周期 指令周期流程 CPU工作周期的标志 CPU访存有四种性质 取指令 取指周期 取地址 间址周期 存取操作数或结果 执行周期 存程序断点 中断周期 二、指令周期的数据流 取指周期的数据流 间址周期的数据流 执行周期数据流 不同指令的执行周期数据流不同 中断周期数据流 指令流水 一、如何提高机器速度 提高访存速度：高速片 cache 多体并行 提高I/O和主机之间的传送速度： 中断 DMA 通道 I/O处理机 多总线 给提高运算速度： 高速芯片 改进算法 快速进位链 提高整机处理能力： 高速器件 改进系统结构，开发系统的并行性 二、系统的并行性 并行的概念 并行{并发两个或两个以上事件在同一时间段发生同时两个或两个以上事件在同一时刻发生（时间上相互重叠）并行 \\{ \\begin{array}{cc} 并发 &amp; 两个或两个以上事件在同一时间段发生 \\\\ 同时 &amp; 两个或两个以上事件在同一时刻发生（时间上相互重叠） \\end{array}并行{并发同时​两个或两个以上事件在同一时间段发生两个或两个以上事件在同一时刻发生（时间上相互重叠）​ 并行性的等级 过程级（程序、进程） 粗粒度 软件实现 指令级（指令之间）（指令内部） 细粒度 硬件实现 三、指令流水原理 指令的串行执行 取指令和执行指令交替进行 指令的二级流水 取指令和执行阶段时间上完全重叠 指令周期减半 速度提高1倍 影响指令流水效率加倍的因素 执行时间&gt; 取指时间 取指令部件----&gt;指令部件缓冲区-----&gt;执行指令部件 条件转移指令对指令流水的影响 必须等上条指令执行结束，才能确定下条指令的地址，造成时间损失 指令的六级流水 四、影响指令流水线性能的因素 结构相关 不同指令争用同一功能部件产生资源冲突 解决方法 停顿 指令存储器和数据存储器分开 指令预取技术（适用于访存周期短的情况） 数据相关 不同指令因重叠操作，可能改变操作数的读/写 访问顺序 写后读相关（RAW） 读后写相关（WAR） 写后写相关（WAW） 解决办法 后推法 采用旁路技术 控制相关 由转移指令引起 五、流水线性能 吞吐率 单位时间内流水线所完成指令或输出结果的数量，设m段的流水线各段时间为Δt\\Delta tΔt 最大吞吐率 Tpmax=1ΔtT_{pmax}=\\frac{1}{\\Delta t}Tpmax​=Δt1​ 实际吞吐率 连续处理n条指令的吞吐率为T=nm⋅Δt+(n−1)⋅ΔtT = \\frac{n}{m\\cdot \\Delta t + (n-1) \\cdot \\Delta t}T=m⋅Δt+(n−1)⋅Δtn​ 加速比SpS_pSp​ m段的流水线的速度与等功能的非流水线的速度之比 设流水线各段时间为 Δt\\Delta tΔt 完成n条指令在m段流水线上共需 T=m⋅Δt+(n−1)⋅ΔtT = m\\cdot \\Delta t + (n-1)\\cdot \\Delta tT=m⋅Δt+(n−1)⋅Δt 完成n条指令在等效的非流水线上共需 T′=nm⋅ΔtT&#x27; = nm\\cdot \\Delta tT′=nm⋅Δt ∴Sp=TT′=nm⋅Δtm⋅Δt+(n−1)⋅Δt=nmm+n−1\\therefore S_p = \\frac{T}{T&#x27;} = \\frac{nm \\cdot \\Delta t}{m \\cdot \\Delta t + (n-1) \\cdot \\Delta t} = \\frac{nm}{m+n-1}∴Sp​=T′T​=m⋅Δt+(n−1)⋅Δtnm⋅Δt​=m+n−1nm​ 效率 流水线中各功能段的利用率 由于流水线由建立时间和排空时间，因此各功能段不可能一直处于工作时间 效率=流水线隔断处于工作时间的时空区流水线中各段总的时空区=mnΔtm(m+n−1)Δt效率 = \\frac{流水线隔断处于工作时间的时空区}{流水线中各段总的时空区} = \\frac{mn \\Delta t}{m(m+n-1)\\Delta t}效率=流水线中各段总的时空区流水线隔断处于工作时间的时空区​=m(m+n−1)ΔtmnΔt​ 六、流水线的多发技术 超标量技术 每个时钟周期内可并发多条独立指令，配置多功能部件 不能调整指令的执行顺序，通过编译优化技术，把可并行执行的指令搭配起来 超流水线技术 在一个时钟周期内再分段（3段），在一个时钟周期内一个功能部件使用多次（3次） 不能调整指令的执行顺序，靠编译程序解决优化问题 超长指令字技术 由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作ma字段的超长指令字（可达几百位） 采用多个处理部件 七、流水线结构 指令流水线结构 运算流水线 中断系统 一、概述 引起中断的各种因素 人为设置的中断 转管指令 程序性事故 溢出、操作码不能识别、除数为零 硬件故障 I/O设备 外部事件 用键盘中断现行程序 中断系统需解决的问题 各中断源如何向CPU提出请求？ 各中断源同时提出请求怎么办？ CPU什么条件、什么时间、以什么方式响应中断 如何保护现场？ 如何寻找入口地址？ 如何恢复现场，如何返回？ 处理中断的过程中又出现心得中断怎么办？ 软件+硬件 二、中断请求标记和中断判优逻辑 中断请求标记 INTR 一个请求源 一个INTR中断请求标记触发器 多个INTR组成中断请求标记寄存器（既可以分散再各个中断源的接口电路中，也可以集中再CPU的中断系统内） 中断判优逻辑 硬件实现（排队器） 分散再各个中断源的接口电路中 集中再CPU内 软件实现（程序查询） 三、中断服务程序入口地址的寻找 硬件向量法 软件查询法 四、中断响应 响应中断的条件 允许中断触发器 EINT = 1 响应中断的时间 中断隐指令 保护程序断点 断点存于待定地址（0号地址）内 寻找服务程序入口地址 向量地址 —&gt;PC 中断识别程序入口地址 M—&gt;PC 硬件关中断 五、保护现场和恢复现场 保护现场{断点中断隐指令完成寄存器内容中断服务程序完场保护现场\\{\\begin{array}{cc}断点 &amp; 中断隐指令完成 \\\\ 寄存器内容 &amp; 中断服务程序完场\\end{array}保护现场{断点寄存器内容​中断隐指令完成中断服务程序完场​ 恢复现场 中断服务程序完成 六、多重中断 多重中断的概念 实现多重中断的条件 提前设置开中断指令 优先级别高的中断源有权中断优先级别低的中断源 屏蔽技术 屏蔽触发器 MASK 屏蔽字 屏蔽技术可改变处理优先等级 响应优先级 不可改变 处理优先级 可改变 屏蔽技术的其他作用 可以认为地屏蔽某个中断源的请求 新屏蔽字的设置 多重中断的断点保护 断点进栈 中断隐指令完成 断点存入“0”地址 中断隐指令完成 程序断点存入“0”地址的断点保护 第九章 控制单元的功能 微操作命令的分析 完成一条指令分为4个工作周期 取指周期 间址周期 执行周期 中断周期 一、取指周期 二、间址周期 三、执行周期 非访存指令 CLA 清A COM 取反 SHR 算术右移 CSL 循环左移 STP 停机指令 访存指令 加法指令 ADD X 存数指令 STA X 取数指令 LDA X 转移指令 无条件转 JMP X 条件转移 BAN X 三类指令的指令周期 非访存指令周期 取指周期----&gt;执行周期 直接访存指令周期 取指周期----&gt;执行周期 间接访存指令周期 取指周期----&gt;间址周期----&gt;执行周期 转移指令周期 取指周期----&gt;执行周期 间接转移指令周期 取指周期----&gt;间址周期----&gt;执行周期 四、中断周期 程序断点存入“0”地址 程序断点进栈 控制单元的功能 一、控制单元的外特性 输入信号 时钟 CU 受时钟控制 一个时钟脉冲，发一个操作命令或一组需要同时执行的操作命令 指令寄存器 OP（IR）----&gt;CU 控制信号与操作码有关 标志 CU 受标志控制 外来信号 INTR 中断请求 HRQ 总线请求 输出信号 CPU内的各种 控制信号 送至控制总线的信号 二、控制信号举例 不采用CPU内部总线的方式 采用CPU内部总线方式 三、多级时序系统 机器周期 机器周期的概念：所有指令执行过程中的一个基准时间 确定机器周期需考虑的因素 每条指令的执行步骤 每一步骤所需时间 基准时间的确定 以完成最复杂指令功能的时间为准 以访问一次存储器的时间为基准 若指令字长=存储子长 取指周期=机器周期 时钟周期（节拍、状态） 一个机器周期内可完成若干个微操作 每个位操作需一定的时间 将一个机器周期分成若干个时间相等的时间段（节拍状态、时钟周期） 时钟周期是控制计算机操作的最小单位时间 用时钟周期控制产生一个或几个微操作命令 多级时序系统 机器周期、节拍（状态）组成多级时序系统 一个指令周期包含若干个机器周期 一个机器周期包含若干个时钟周期 机器速度与机器主频的关系 机器的主频fff 越快机器的速度也越快 在机器周期所含时钟周期数相同的前提下，两机平均指令执行速度之比等于两机主频之比MIPS1MIPS2=f1f2\\frac{MIPS_1}{MIPS_2} = \\frac{f_1}{f_2}MIPS2​MIPS1​​=f2​f1​​ 机器速度不仅与主频有关，还与机器周期中所含的时间周期数（主频的倒数）以及指令周期中所含的机器周期数有关 四、控制方式 产生不同微操作命令序列所用的时序控制方式 同步控制 任一微操作均由统一基准时标的时序信号控制 采用定长的机器周期 以最长的微操作序列和最复杂的微操作为标准 采用不定长的机器周期 机器周期内节拍数不等 采用中央控制和局部控制相结合的方法 异步控制 无基准时标信号 无固定的周期节拍和严格的时钟同步 采用应答方式 联合控制方式 同步和异步相结合 人工控制方式 Reset 连续和单条指令执行转换开关 符合停机开关 第十章 控制单元的设计 组合逻辑设计 一、组合逻辑控制单元框图 CU外特性 节拍信号 二、微操作的节拍安排 采用同步控制方式 一个机器周期内由3个节拍（时钟周期） 安排微操作时序的原则 原则一 微操作的先后顺序不得随意更改 原则二 被控对象不同的微操作，尽量安排在一个节拍内完成 原则三 占用时间较短的微操作，尽量安排在一个节拍内完成，并允许有先后顺序 取指周期的微操作的节拍安排 间址周期微操作的节拍安排 执行周期微操作的节拍安排 中断周期微操作的节拍安排 三、组合逻辑设计步骤 列出操作时间表 写出微操作命令的最简表达式 画出逻辑图 特点 思路清晰，简单明了 庞杂，调试困难，修改困难 速度快（RISC） 微程序设计 一、微程序设计思想的产生 1951年英国剑桥大学教授 Wikes 一条机器指令对应一个微程序 保存在ROM当中（存储逻辑） 二、微程序控制单元框图及工作原理 机器指令对应的微程序 微程序控制单元的基本框图 工作原理 取指阶段 执行取指微指令 执行阶段 执行LDA微程序 三、微指令的编码方式（控制方式） 直接编码（直接控制）方式 在微指令的操作控制字段中，每一位代表一个微操作命令 速度最快 字段直接编码方式 将微指令的控制字段分成若干“段” 每段经译码后发出控制信号（显式编码） 缩短了微指令字长，增加译码时间 字段间接编码方式 隐式编码 混合编码 其他 四、微指令序列地址的形成 微指令的下地址字段指出 根据机器指令的操作码形成 增量计数器 分支转移 通过测试网络 由硬件产生微程序入口地址 第一条微指令地址 由专门硬件产生 后续微指令地址形成方式原理图 五、微指令格式 水平型微指令 一次能定义并执行多个并行操作 垂直型微指令 两种微指令格式的比较 水平型微指令比垂直型微指令并行操作能力强，灵活性强 水平型微指令执行一条机器指令所要的微指令数目少，速度快 水平型微指令用较短的微程序结构换取较长的微指令结构 水平型微指令与机器指令差别大 六、静态微程序设计和动态微程序设计 静态 微程序无需改变，采用ROM 动态 通过改变微指令和微程序改变机器指令，有利于仿真，采用EPROM 七、毫微程序设计 毫微程序设计的基本概念 微程序设计 用微程序解释机器指令 毫微程序设计 用 毫微程序解释指令 毫微指令和微指令的关系好比微指令与机器指令 毫微程序控制存储器的基本组成 八、串行微程序控制和并行微程序控制 九、微程序设计举例 写出队形机器指令的微操作及节拍安排、 取指阶段微操作分析 取指阶段的微操作及节拍安排 执行阶段的微操作及节拍安排 确定微指令格式 微指令的编码方式 后续微指令的地址形成方式 微指令字长 微指令字长的确定 省去了CMAR的控制存储器 定义微指令操作控制字段每一位的微操作 编写微指令码点","categories":[],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://yucongxing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]}],"categories":[],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"https://yucongxing.github.io/tags/C-Primer/"},{"name":"hexo","slug":"hexo","permalink":"https://yucongxing.github.io/tags/hexo/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://yucongxing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]}